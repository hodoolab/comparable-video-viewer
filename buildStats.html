<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>comparable-video-viewer Rollup Report (Tue Oct 08 2019)</title>
  <style>@font-face {
  font-family: "Oswald";
  font-style: normal;
  font-display: swap;
  font-weight: 500;
  src: local("Oswald Medium"), local("Oswald-Medium"), url("data:font/woff2;base64,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") format("woff2"), url("data:font/woff;base64,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") format("woff");
}
html {
  background-color: #f7eedf;
  color: #333;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  width: 100%;
}

body {
  width: 100%;
  padding: 0;
  margin: 0;
}

svg {
  vertical-align: middle;
}

h1 {
  font-family: "Oswald", "HelveticaNeue-CondensedBold", "Arial Narrow", sans-serif;
  font-weight: 500;
  font-size: 70px;
  text-transform: uppercase;
  text-align: center;
}

.chart {
  position: relative;
  margin: 0 auto;
  min-height: 350px;
}

#charts {
  width: 1000px;
  margin: 0 auto;
}

.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  margin: 0;
  font-style: normal;
  font-weight: 400;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  opacity: 0;
}

circle {
  stroke: white;
}

text {
  font-size: 0.7em;
  fill: white;
}</style>
  <style>undefined</style>
</head>
<body>
  <h1>comparable-video-viewer Rollup Report (Tue Oct 08 2019)</h1>
  <div id="charts"></div>
  <script>window.nodesData = [{"id":"comparable-video-viewer.umd.production.min.js","root":{"name":"root","children":[{"name":"src","children":[{"name":"Config.ts","children":[],"size":0,"originalSize":367},{"name":"Controls","children":[{"name":"Seek.tsx","children":[],"size":387,"originalSize":1331},{"name":"SVG.tsx","children":[],"size":1360,"originalSize":1653},{"name":"index.tsx","children":[],"size":1509,"originalSize":3529}]},{"name":"Utils.ts","children":[],"size":1235,"originalSize":4675},{"name":"LoopCanvas.tsx","children":[],"size":2935,"originalSize":2854},{"name":"ComparableVideoViewer.tsx","children":[],"size":9876,"originalSize":19942},{"name":"index.ts","children":[],"size":0,"originalSize":197}]},{"name":"node_modules","children":[{"name":"babel-plugin-transform-async-to-promises","children":[{"name":"helpers.js","children":[],"size":1434,"originalSize":19837}]}]},{"name":"\u0000rollupPluginBabelHelpers.js","children":[],"size":0,"originalSize":42833}]}}];</script>
  <script>(function () {
  'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
  }

  function selection_cloneDeep() {
    return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents = {};

  var event = null;

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = event; // Events can be reentrant (e.g., focus).
      event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function sourceEvent() {
    var current = event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function d3mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  var prefix = "$";

  function Map() {}

  Map.prototype = map.prototype = {
    constructor: Map,
    has: function(key) {
      return (prefix + key) in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function() {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function() {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function(f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map(object, f) {
    var map = new Map;

    // Copy constructor.
    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) map.set(i, object[i]);
      else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  function d3nest() {
    var keys = [],
        sortKeys = [],
        sortValues,
        rollup,
        nest;

    function apply(array, depth, createResult, setResult) {
      if (depth >= keys.length) {
        if (sortValues != null) array.sort(sortValues);
        return rollup != null ? rollup(array) : array;
      }

      var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          value,
          valuesByKey = map(),
          values,
          result = createResult();

      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
          values.push(value);
        } else {
          valuesByKey.set(keyValue, [value]);
        }
      }

      valuesByKey.each(function(values, key) {
        setResult(result, key, apply(values, depth, createResult, setResult));
      });

      return result;
    }

    function entries(map, depth) {
      if (++depth > keys.length) return map;
      var array, sortKey = sortKeys[depth - 1];
      if (rollup != null && depth >= keys.length) array = map.entries();
      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
    }

    return nest = {
      object: function(array) { return apply(array, 0, createObject, setObject); },
      map: function(array) { return apply(array, 0, createMap, setMap); },
      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
      key: function(d) { keys.push(d); return nest; },
      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
      sortValues: function(order) { sortValues = order; return nest; },
      rollup: function(f) { rollup = f; return nest; }
    };
  }

  function createObject() {
    return {};
  }

  function setObject(object, key, value) {
    object[key] = value;
  }

  function createMap() {
    return map();
  }

  function setMap(map, key, value) {
    map.set(key, value);
  }

  function Set() {}

  var proto = map.prototype;

  Set.prototype = set.prototype = {
    constructor: Set,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  function set(object, f) {
    var set = new Set;

    // Copy constructor.
    if (object instanceof Set) object.each(function(value) { set.add(value); });

    // Otherwise, assume it’s an array.
    else if (object) {
      var i = -1, n = object.length;
      if (f == null) while (++i < n) set.add(object[i]);
      else while (++i < n) set.add(f(object[i], i, object));
    }

    return set;
  }

  let count = 0;

  class Id {
    constructor(id) {
      this._id = id;
      this._href = createUrl({ hash: id }).href;
    }

    get id() {
      return this._id;
    }

    get href() {
      return this._href;
    }

    toString() {
      return `url(${this.href})`;
    }
  }

  function uid(name) {
    count += 1;
    const id = ["O", name, count].filter(Boolean).join("-");
    return new Id(id);
  }

  function createUrl(options = {}) {
    const url = new URL(window.location);
    return Object.assign(url, options);
  }

  function getAncestors(node) {
    const parents = [];
    while (node != null) {
      parents.push(node);
      node = node.parent;
    }
    return parents;
  }

  function color(node) {
    if (node.children && node.children.length) {
      const parents = getAncestors(node);
      const hasNodeModules = !!parents.find(n => {
        return n.data.name === "node_modules";
      });
      return hasNodeModules ? "#599e59" : "#487ea4";
    } else {
      return "#db7100";
    }
  }

  function count$1(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;
    else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  function node_count() {
    return this.eachAfter(count$1);
  }

  function node_each(callback) {
    var node = this, current, next = [node], children, i, n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        callback(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    } while (next.length);
    return this;
  }

  function node_eachBefore(callback) {
    var node = this, nodes = [node], children, i;
    while (node = nodes.pop()) {
      callback(node), children = node.children;
      if (children) for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
    return this;
  }

  function node_eachAfter(callback) {
    var node = this, nodes = [node], next = [], children, i, n;
    while (node = nodes.pop()) {
      next.push(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  }

  function node_sum(value) {
    return this.eachAfter(function(node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path(end) {
    var start = this,
        ancestor = leastCommonAncestor(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }

  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants() {
    var nodes = [];
    this.each(function(node) {
      nodes.push(node);
    });
    return nodes;
  }

  function node_leaves() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links() {
    var root = this, links = [];
    root.each(function(node) {
      if (node !== root) { // Don’t include the root’s parent, if any.
        links.push({source: node.parent, target: node});
      }
    });
    return links;
  }

  function hierarchy(data, children) {
    var root = new Node(data),
        valued = +data.value && (root.value = data.value),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    if (children == null) children = defaultChildren;

    while (node = nodes.pop()) {
      if (valued) node.value = +node.data.value;
      if ((childs = children(node.data)) && (n = childs.length)) {
        node.children = new Array(n);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight);
  }

  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }

  function defaultChildren(d) {
    return d.children;
  }

  function copyData(node) {
    node.data = node.data.data;
  }

  function computeHeight(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && (node.height < ++height));
  }

  function Node(data) {
    this.data = data;
    this.depth =
    this.height = 0;
    this.parent = null;
  }

  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy
  };

  var slice = Array.prototype.slice;

  function shuffle(array) {
    var m = array.length,
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }

    return array;
  }

  function enclose(circles) {
    var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

    while (i < n) {
      p = circles[i];
      if (e && enclosesWeak(e, p)) ++i;
      else e = encloseBasis(B = extendBasis(B, p)), i = 0;
    }

    return e;
  }

  function extendBasis(B, p) {
    var i, j;

    if (enclosesWeakAll(p, B)) return [p];

    // If we get here then B must have at least one element.
    for (i = 0; i < B.length; ++i) {
      if (enclosesNot(p, B[i])
          && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
        return [B[i], p];
      }
    }

    // If we get here then B must have at least two elements.
    for (i = 0; i < B.length - 1; ++i) {
      for (j = i + 1; j < B.length; ++j) {
        if (enclosesNot(encloseBasis2(B[i], B[j]), p)
            && enclosesNot(encloseBasis2(B[i], p), B[j])
            && enclosesNot(encloseBasis2(B[j], p), B[i])
            && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
          return [B[i], B[j], p];
        }
      }
    }

    // If we get here then something is very wrong.
    throw new Error;
  }

  function enclosesNot(a, b) {
    var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }

  function enclosesWeak(a, b) {
    var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function enclosesWeakAll(a, B) {
    for (var i = 0; i < B.length; ++i) {
      if (!enclosesWeak(a, B[i])) {
        return false;
      }
    }
    return true;
  }

  function encloseBasis(B) {
    switch (B.length) {
      case 1: return encloseBasis1(B[0]);
      case 2: return encloseBasis2(B[0], B[1]);
      case 3: return encloseBasis3(B[0], B[1], B[2]);
    }
  }

  function encloseBasis1(a) {
    return {
      x: a.x,
      y: a.y,
      r: a.r
    };
  }

  function encloseBasis2(a, b) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
        l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x1 + x2 + x21 / l * r21) / 2,
      y: (y1 + y2 + y21 / l * r21) / 2,
      r: (l + r1 + r2) / 2
    };
  }

  function encloseBasis3(a, b, c) {
    var x1 = a.x, y1 = a.y, r1 = a.r,
        x2 = b.x, y2 = b.y, r2 = b.r,
        x3 = c.x, y3 = c.y, r3 = c.r,
        a2 = x1 - x2,
        a3 = x1 - x3,
        b2 = y1 - y2,
        b3 = y1 - y3,
        c2 = r2 - r1,
        c3 = r3 - r1,
        d1 = x1 * x1 + y1 * y1 - r1 * r1,
        d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
        d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
        ab = a3 * b2 - a2 * b3,
        xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
        xb = (b3 * c2 - b2 * c3) / ab,
        ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
        yb = (a2 * c3 - a3 * c2) / ab,
        A = xb * xb + yb * yb - 1,
        B = 2 * (r1 + xa * xb + ya * yb),
        C = xa * xa + ya * ya - r1 * r1,
        r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
    return {
      x: x1 + xa + xb * r,
      y: y1 + ya + yb * r,
      r: r
    };
  }

  function place(b, a, c) {
    var dx = b.x - a.x, x, a2,
        dy = b.y - a.y, y, b2,
        d2 = dx * dx + dy * dy;
    if (d2) {
      a2 = a.r + c.r, a2 *= a2;
      b2 = b.r + c.r, b2 *= b2;
      if (a2 > b2) {
        x = (d2 + b2 - a2) / (2 * d2);
        y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
        c.x = b.x - x * dx - y * dy;
        c.y = b.y - x * dy + y * dx;
      } else {
        x = (d2 + a2 - b2) / (2 * d2);
        y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
        c.x = a.x + x * dx - y * dy;
        c.y = a.y + x * dy + y * dx;
      }
    } else {
      c.x = a.x + c.r;
      c.y = a.y;
    }
  }

  function intersects(a, b) {
    var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }

  function score(node) {
    var a = node._,
        b = node.next._,
        ab = a.r + b.r,
        dx = (a.x * b.r + b.x * a.r) / ab,
        dy = (a.y * b.r + b.y * a.r) / ab;
    return dx * dx + dy * dy;
  }

  function Node$1(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
  }

  function packEnclose(circles) {
    if (!(n = circles.length)) return 0;

    var a, b, c, n, aa, ca, i, j, k, sj, sk;

    // Place the first circle.
    a = circles[0], a.x = 0, a.y = 0;
    if (!(n > 1)) return a.r;

    // Place the second circle.
    b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
    if (!(n > 2)) return a.r + b.r;

    // Place the third circle.
    place(b, a, c = circles[2]);

    // Initialize the front-chain using the first three circles a, b and c.
    a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
    a.next = c.previous = b;
    b.next = a.previous = c;
    c.next = b.previous = a;

    // Attempt to place each remaining circle…
    pack: for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node$1(c);

      // Find the closest intersecting circle on the front-chain, if any.
      // “Closeness” is determined by linear distance along the front-chain.
      // “Ahead” or “behind” is likewise determined by linear distance.
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);

      // Success! Insert the new circle c between a and b.
      c.previous = a, c.next = b, a.next = b.previous = b = c;

      // Compute the new closest circle pair to the centroid.
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }

    // Compute the enclosing circle of the front chain.
    a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

    // Translate the circles to put the enclosing circle around the origin.
    for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

    return c.r;
  }

  function optional(f) {
    return f == null ? null : required(f);
  }

  function required(f) {
    if (typeof f !== "function") throw new Error;
    return f;
  }

  function constantZero() {
    return 0;
  }

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function defaultRadius(d) {
    return Math.sqrt(d.value);
  }

  function d3pack() {
    var radius = null,
        dx = 1,
        dy = 1,
        padding = constantZero;

    function pack(root) {
      root.x = dx / 2, root.y = dy / 2;
      if (radius) {
        root.eachBefore(radiusLeaf(radius))
            .eachAfter(packChildren(padding, 0.5))
            .eachBefore(translateChild(1));
      } else {
        root.eachBefore(radiusLeaf(defaultRadius))
            .eachAfter(packChildren(constantZero, 1))
            .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
            .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
      }
      return root;
    }

    pack.radius = function(x) {
      return arguments.length ? (radius = optional(x), pack) : radius;
    };

    pack.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
    };

    pack.padding = function(x) {
      return arguments.length ? (padding = typeof x === "function" ? x : constant$1(+x), pack) : padding;
    };

    return pack;
  }

  function radiusLeaf(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }

  function packChildren(padding, k) {
    return function(node) {
      if (children = node.children) {
        var children,
            i,
            n = children.length,
            r = padding(node) * k || 0,
            e;

        if (r) for (i = 0; i < n; ++i) children[i].r += r;
        e = packEnclose(children);
        if (r) for (i = 0; i < n; ++i) children[i].r -= r;
        node.r = e + r;
      }
    };
  }

  function translateChild(k) {
    return function(node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  var format_1 = format;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

  var map$1 = {
    b:  1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5),
  };

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unit=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }

    var mag = Math.abs(value);
    var thousandsSeparator = (options && options.thousandsSeparator) || '';
    var unitSeparator = (options && options.unitSeparator) || '';
    var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = (options && options.unit) || '';

    if (!unit || !map$1[unit.toLowerCase()]) {
      if (mag >= map$1.pb) {
        unit = 'PB';
      } else if (mag >= map$1.tb) {
        unit = 'TB';
      } else if (mag >= map$1.gb) {
        unit = 'GB';
      } else if (mag >= map$1.mb) {
        unit = 'MB';
      } else if (mag >= map$1.kb) {
        unit = 'KB';
      } else {
        unit = 'B';
      }
    }

    var val = value / map$1[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);

    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }

    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }

    return str + unitSeparator + unit;
  }

  // https://www.d3-graph-gallery.com/graph/interactivity_tooltip.html#template

  const createTooltip = node =>
    node
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "2px")
      .style("border-radius", "5px")
      .style("padding", "5px");

  const createMouseover = tooltipNode => () => tooltipNode.style("opacity", 1);

  const createMousemove = (tooltipNode, container, totalSize) => d => {
    const [x, y] = d3mouse(container);
    const nodePath = d
      .ancestors()
      .reverse()
      .map(d => d.data.name)
      .join("/");

    const percentageNum = (100 * d.value) / totalSize;
    const percentage = percentageNum.toFixed(2);
    const percentageString = percentage + "%";

    const str = `${nodePath}<br/><b>${format_1(d.value || d.size)}</b><br/>${percentageString}`;

    tooltipNode
      .html(str)
      .style("left", x + 30 + "px")
      .style("top", y + "px");
  };

  const createMouseleave = tooltipNode => () => tooltipNode.style("opacity", 0);

  const WIDTH = 1000;
  const HEIGHT = 1000;

  const chartsContainer = document.querySelector("#charts");

  for (const { id, root: data } of window.nodesData) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `
      <div class="chart">
        <h3>${id}</h3>
      </div>
      `;
    const chartNode = wrapper.querySelector(".chart");
    chartsContainer.appendChild(chartNode);

    const root = hierarchy(data)
      .sum(d => {
        if (d.children && d.children.length) {
          return 0;
        } else {
          return d.size;
        }
      })
      .sort();

    const totalSize = root.value;

    const layout = d3pack()
      .size([WIDTH - 2, HEIGHT - 2])
      .padding(3);

    const tooltip = createTooltip(select(chartNode));

    layout(root);

    const svg = select(chartNode)
      .append("svg")
      .attr("viewBox", [0, 0, WIDTH, HEIGHT])
      .attr("text-anchor", "middle");

    const shadow = uid("shadow");

    svg
      .append("filter")
      .attr("id", shadow.id)
      .append("feDropShadow")
      .attr("flood-opacity", 0.3)
      .attr("dx", 0)
      .attr("dy", 1);

    const node = svg
      .selectAll("g")
      .data(
        d3nest()
          .key(d => d.height)
          .entries(root.descendants())
      )
      .join("g")
      .attr("filter", shadow)
      .selectAll("g")
      .data(d => d.values)
      .join("g")
      .attr("transform", d => `translate(${d.x + 1},${d.y + 1})`)
      .on("mouseover", createMouseover(tooltip))
      .on("mousemove", createMousemove(tooltip, chartNode, totalSize))
      .on("mouseleave", createMouseleave(tooltip));

    node
      .append("circle")
      .attr("r", d => d.r)
      .attr("fill", d => color(d));

    const leaf = node.filter(d => !d.children);

    leaf.select("circle").attr("id", d => (d.leafUid = uid("leaf")).id);

    leaf
      .append("clipPath")
      .attr("id", d => (d.clipUid = uid("clip")).id)
      .append("use")
      .attr("xlink:href", d => d.leafUid.href);

    leaf
      .append("text")
      .attr("clip-path", d => d.clipUid)
      .selectAll("tspan")
      .data(d => d.data.name.split(/(?=[A-Z][^A-Z])/g))
      .join("tspan")
      .attr("x", 0)
      .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.8}em`)
      .text(d => d);
  }

}());
</script>
</body>
</html>
